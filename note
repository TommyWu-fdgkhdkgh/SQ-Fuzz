
g++ -DDOC_PATH=\"/usr/local/share/doc/afl\" ./SQ-fuzz.cpp
-DDOC_PATH就可以對程式內的DOC_PATH定義micro，所以才會在裡面找不到對DOC_PATH的宣告

g++ -Idl -DDOC_PATH=\"/home/tommy/\" -DBIN_PATH=\"/usr/local/bin\"   ./SQ-Fuzz.cpp  -ldl
g++ -Llibxml2-2.9.10/.libs -Ilibxml2-2.9.10/include ./parser.cpp -lxml2

https://github.com/fdgkhdkgh/winafl/blob/master/custom_xmlparse.c 我以前的寫法

./a.out -i a -o b -x ~/AFL/dictionaries/png.dict  -- ./test/a.out @@

-ldl才能正常引用dlopen等等
https://blog.csdn.net/qq_22122811/article/details/52738134
其他進階的議題：
https://www.tldp.org/HOWTO/pdf/C++-dlopen.pdf

------------

2020/02/29

都沒考慮到sync的問題，之後要注意一下


------------

2020/02/27

\[VIDEO_FORMAT\]  在\[ \]間的就是變數名稱，當想要顯示"\["的時候，就用"\\["把它跳脫掉

內建的變數名稱
STRING
STRING:0:100 : 長度0~100的字串
INT
INT:-10:10   : -10~10間的隨機數字
DOUBLE
BOOL
INPUT_FILE   : 作為輸入的檔案名稱

PARAMETER裡，MUST欄位為true的話，就是一定需要加入的命令列引數
MUST欄位為false的話，就是需要隨機接上的參數

改變一下順序
先實做出原本沒有多目標覆蓋率指引的argv-fuzz + afl-fuzz
在這邊存個檔（ 可以當作比較目標，比較有多目標覆蓋率指引，跟沒有的差異）

最後可以多塞一點各式各樣的變異引擎，然後混著用看看
例如argv-fuzz, xmlfuzzer(http://komar.in/en/code/xmlfuzzer) , afl-fuzz可以混搭


prog-fuzz要跟afl的變異引擎一起使用的話，就必須要想辦法把節點的資訊存成檔案，並能在下一次進行變異時引用


需要測試效率：
prog-fuzz v.s. afl-fuzz 分支覆蓋率
Multi-target (No Multi-target coverage driven) v.s. Multi-target (has Multi-target coverage driven) 分支覆蓋率
Multi-taget v.s. normal afl-fuzz 分支覆蓋率

選擇要用哪一個fuzzing engine放在個別project的設定檔好了（因為也是看個別project需要）

------------

2020/02/26

可以在queue這個結構裡新增argv

可以新增資料夾 queue_state，儲存每個queue對應的檔案名稱，以及argv

在add_to_queue這個function的參數可以多加一個argv

可以開始把分析json格式的library或是分析xml的library也都加進來

1. 先做好儲存argv到queue結構，以及輸出queue結構的資訊到queue_info
2. 把之前做的粗糙argv fuzzing帶進來，看看兩邊的效果有沒有差異(一個是有意識到多目標的覆蓋率回饋，一個是沒有亦是道有多目標的覆蓋率回饋) 

3. 開始認真做argv fuzzing



------------------------------------------------------------------------------

希望有的功能：

一：
將每個受測目標歸類為一個物件
那個物件描述了有哪些argv可供我們變異
並且也描述了那個物件所要使用的mutator....等等

可以像是群聯那樣的想法
用同一個應用程式，去承接不同的應用程式，不同的可變動範圍，不同的變異方式




二：
這個以前就寫過了，但還是提一下
自動執行所有crash & hang的測試資料，並且用--------------區隔每個檔案的輸出


1. 解析設定檔
設定檔裡面包含了有哪些目標程式(objdump? gcc? flex?)
目標程式是插樁過得？還是沒有插樁過得？或在這個選項直接選擇想要的模式(-i, -o, -Q...)
目標程式想要用那一種mutation engine？（我目前就把每個mutation engine都當作fuzz_one實做，包含變異跟執行的功能）
有沒有要開啟argv fuzzing?有可能這個東西也當作mutation engine的一部分吧
我的想法是列一個虛擬檔案，把這個虛擬檔案當成一般的測試資料來進行變異，最後要執行的時候，再把這個檔案翻譯成各個目標
但是碰上gcc/g++這類有語法語意的東西，可能也沒辦法完全這樣做了。
但是可以把"虛擬檔案"當作一個概念，在變異測試輸入不要這樣做，但其他地方可以這樣做

2. 選擇目標(objdump, gcc ??)

3. 照著設定檔的指示，用特定的mutation engine進行fuzzing

---------

開始測試c++的afl fuzz跟 c的afl fuzz哪邊比較快
目前是afl-fuzz快上一點點 
但真的就一點點


--------

功能：可以把特定的變數換成某一組隨機字串
在fuzz ffmpeg時，可以從合法的format中選擇一個



